<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Play 2048 with Powerups | Aesthetic Responsive 2048 Game</title>
  <meta name="description" content="Play an enhanced, aesthetic, mobile-friendly 2048 game with themes, powerups (undo, shuffle, double, spawn), dark mode, and smooth animations. Challenge yourself now!">
  <meta name="keywords" content="2048 game, play 2048, online puzzle game, powerups 2048, responsive 2048, dark mode 2048, strategy game, casual game">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
  <link rel="canonical" href="https://aniketxraj.me/">
  <meta name="robots" content="index, follow">
  <meta name="author" content="Aniket">
  <meta name="theme-color" content="#222831">
  <meta property="og:type" content="website">
  <meta property="og:title" content="Play 2048 with Powerups | Aesthetic, Fast & Mobile Friendly">
  <meta property="og:description" content="Enjoy a beautiful version of 2048 featuring custom themes, powerups, animations, and full mobile support. Can you reach 4096?">
  <meta property="og:url" content="https://aniketxraj.me/">
  <meta property="og:image" content="https://aniketxraj.me/banner.jpg">
  <meta property="og:site_name" content="Aesthetic 2048">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Play 2048 with Powerups | Aesthetic Game">
  <meta name="twitter:description" content="Modern 2048 with themes, powerups & smooth animations.">
  <meta name="twitter:image" content="https://aniketxraj.me/banner.jpg">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="preload" href="https://aniketxraj.me/banner.jpg" as="image">
  <script type="application/ld+json">{"@context":"https://schema.org","@type":"Game","name":"Aesthetic 2048 with Powerups","genre":"Puzzle","applicationCategory":"Game","operatingSystem":"Any","playMode":"SinglePlayer","author":{"@type":"Person","name":"Aniket"},"description":"An enhanced online 2048 puzzle game featuring powerups, themes, animations, and mobile-friendly controls.","image":"https://aniketxraj.me/banner.jpg","inLanguage":"en","url":"https://aniketxraj.me/"}</script>
  <style>
    /* Basic 2048 styles */
    :root {
      --bg: #0f1115;
      --card: #171b21;
      --text: #e8edf2;
      --text-dim: #b5c0cc;
      --accent: #5aa9ff;
      --border: #2a3441;
      --gap: 8px;
      --radius: 8px;
      --tile-empty: #1f252d;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 1rem;
    }
    
    main {
      max-width: 600px;
      margin: 0 auto;
    }
    
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
      gap: 1rem;
    }
    
    h1 {
      font-size: 2rem;
      color: var(--accent);
      margin: 0;
    }
    
    .badge {
      display: inline-block;
      padding: 0.25rem 0.6rem;
      font-size: 0.65rem;
      letter-spacing: 0.8px;
      text-transform: uppercase;
      border: 1px solid var(--border);
      border-radius: 20px;
      background: var(--card);
      color: var(--text-dim);
      margin-left: 0.5rem;
    }
    
    .stats {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    
    .stat-box {
      background: var(--card);
      padding: 0.75rem;
      border-radius: var(--radius);
      text-align: center;
      min-width: 80px;
    }
    
    .stat-box h4 {
      font-size: 0.75rem;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.25rem;
    }
    
    .stat-box .value {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text);
    }
    
    .btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: var(--radius);
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.25s;
      font-weight: 500;
    }
    
    .btn:hover {
      background: #4a9aef;
      transform: translateY(-1px);
    }
    
    .btn.primary {
      background: var(--accent);
    }
    
    .board-wrapper {
      position: relative;
      margin: 2rem auto;
    }
    
    .board {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: var(--gap);
      background: var(--card);
      padding: var(--gap);
      border-radius: var(--radius);
      width: 100%;
      max-width: 400px;
      aspect-ratio: 1;
    }
    
    .tile {
      background: var(--tile-empty);
      border-radius: calc(var(--radius) * 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 1.25rem;
      color: var(--text);
      transition: all 0.25s;
    }
    
    .tile[data-value="2"] { background: #eee4da; color: #776e65; }
    .tile[data-value="4"] { background: #ede0c8; color: #776e65; }
    .tile[data-value="8"] { background: #f2b179; color: #f9f6f2; }
    .tile[data-value="16"] { background: #f59563; color: #f9f6f2; }
    .tile[data-value="32"] { background: #f67c5f; color: #f9f6f2; }
    .tile[data-value="64"] { background: #f65e3b; color: #f9f6f2; }
    .tile[data-value="128"] { background: #edcf72; color: #f9f6f2; font-size: 1rem; }
    .tile[data-value="256"] { background: #edcc61; color: #f9f6f2; font-size: 1rem; }
    .tile[data-value="512"] { background: #edc850; color: #f9f6f2; font-size: 1rem; }
    .tile[data-value="1024"] { background: #edc53f; color: #f9f6f2; font-size: 0.9rem; }
    .tile[data-value="2048"] { background: #edc22e; color: #f9f6f2; font-size: 0.9rem; }
    .tile[data-value="4096"] { background: #3c3a32; color: #f9f6f2; font-size: 0.9rem; }
    
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      border-radius: var(--radius);
      text-align: center;
    }
    
    .overlay.active {
      display: flex;
    }
    
    .overlay h2 {
      margin-bottom: 1rem;
      color: var(--accent);
    }
    
    /* Custom Setup Styles */
    .custom-setup-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: var(--gap);
      width: 100%;
      max-width: 360px;
      aspect-ratio: 1/1;
      margin: 0 auto 1rem;
    }
    
    .custom-cell {
      position: relative;
      background: var(--tile-empty);
      border: 1px dashed rgba(255, 255, 255, 0.15);
      border-radius: calc(var(--radius) * 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 1.1rem;
      cursor: pointer;
      color: var(--text);
      user-select: none;
      transition: 0.25s background, 0.25s border-color;
    }
    
    .custom-cell:hover,
    .custom-cell:focus-visible {
      background: rgba(255, 255, 255, 0.08);
      outline: none;
      border-color: var(--accent);
    }
    
    .custom-cell.empty {
      color: var(--text-dim);
      font-weight: 400;
      font-size: 1rem;
    }
    
    .custom-setup-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
    }
    
    .custom-setup-actions .btn {
      flex: 1 1 auto;
      min-width: 110px;
    }
    
    .custom-help {
      font-size: 0.65rem;
      color: var(--text-dim);
      margin-top: 0.35rem;
      line-height: 1.3;
    }
    
    @media (max-width: 520px) {
      .custom-setup-actions .btn {
        flex: 1 1 45%;
      }
      .top-bar {
        flex-direction: column;
        align-items: center;
      }
      .stats {
        justify-content: center;
      }
    }
  </style>
</head>
<body data-theme="neon">
  <main>
    <div>
      <div class="top-bar" aria-label="Game header">
        <div>
          <h1>Aesthetic 2048 <span class="badge">Powerups</span></h1>
          <button class="btn" id="customSetupBtn" style="margin-top: 0.6rem; font-size: 0.7rem;">Custom Setup</button>
        </div>
        <div class="stats">
          <div class="stat-box" aria-live="polite">
            <h4>Score</h4>
            <div class="value" id="score">0</div>
          </div>
          <div class="stat-box">
            <h4>Best</h4>
            <div class="value" id="best">0</div>
          </div>
          <div class="stat-box">
            <h4>Moves</h4>
            <div class="value" id="moves">0</div>
          </div>
          <div class="stat-box">
            <h4>Highest</h4>
            <div class="value" id="highestTile">0</div>
          </div>
        </div>
      </div>
      
      <div class="board-wrapper" id="boardWrapper">
        <div id="gameBoard" class="board" aria-label="2048 game board" role="application"></div>
        
        <!-- Start Overlay -->
        <div id="startOverlay" class="overlay active" role="dialog" aria-modal="true">
          <h2>Welcome to 2048!</h2>
          <p>Use arrow keys to move tiles. Combine tiles with the same number to reach 2048!</p>
          <button class="btn primary" onclick="startGame()">Start Game</button>
        </div>
        
        <!-- Game Over Overlay -->
        <div id="gameOverOverlay" class="overlay" role="dialog" aria-modal="true">
          <h2>Game Over!</h2>
          <p>Your Score: <span id="finalScore">0</span></p>
          <button class="btn primary" onclick="restartGame()">Try Again</button>
        </div>
        
        <!-- Win Overlay -->
        <div id="winOverlay" class="overlay" role="dialog" aria-modal="true">
          <h2>You Win!</h2>
          <p>Congratulations! You reached 2048!</p>
          <button class="btn primary" onclick="continueGame()">Continue</button>
          <button class="btn" onclick="restartGame()">New Game</button>
        </div>
        
        <!-- Custom Setup Overlay -->
        <div id="customSetupOverlay" class="overlay custom-setup-overlay" role="dialog" aria-modal="true" aria-labelledby="customSetupTitle">
          <h2 id="customSetupTitle">Custom Setup</h2>
          <div class="custom-setup-grid" id="customSetupGrid" aria-label="Editable starting grid"></div>
          <div class="custom-setup-actions">
            <button class="btn" id="csClearBtn">Clear</button>
            <button class="btn" id="csRandomBtn">Random Pair</button>
            <button class="btn" id="csBalanceBtn">Balance</button>
            <button class="btn primary" id="csStartBtn">Start Game</button>
            <button class="btn" id="csCancelBtn">Cancel</button>
          </div>
          <div class="custom-help">Click or press Enter/Space to cycle: empty→2→4→...→4096. Shift+Click or Shift+Enter cycles backward. Need at least 2 tiles to begin.</div>
        </div>
      </div>
    </div>
  </main>

  <script>
    // Game constants
    const SIZE = 4;
    
    // Game state
    let board = [];
    let score = 0;
    let moves = 0;
    let highestTile = 0;
    let hasWon = false;
    let suppressWinUntilNew2048 = false;
    let milestoneTiles = new Set();
    
    // DOM elements
    const gameBoard = document.getElementById('gameBoard');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const movesEl = document.getElementById('moves');
    const highestTileEl = document.getElementById('highestTile');
    const startOverlay = document.getElementById('startOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const winOverlay = document.getElementById('winOverlay');
    const customSetupOverlay = document.getElementById('customSetupOverlay');
    const customSetupGridEl = document.getElementById('customSetupGrid');
    const customSetupBtn = document.getElementById('customSetupBtn');
    const csClearBtn = document.getElementById('csClearBtn');
    const csRandomBtn = document.getElementById('csRandomBtn');
    const csBalanceBtn = document.getElementById('csBalanceBtn');
    const csStartBtn = document.getElementById('csStartBtn');
    const csCancelBtn = document.getElementById('csCancelBtn');
    
    // Custom setup state
    let customBoardData = Array.from({length: SIZE}, () => Array(SIZE).fill(0));
    
    // Initialize game
    function init() {
      initBoard();
      renderBoard();
      updateStats();
      loadBestScore();
      setupEventListeners();
    }
    
    function initBoard() {
      board = Array.from({length: SIZE}, () => Array(SIZE).fill(0));
    }
    
    function setupEventListeners() {
      document.addEventListener('keydown', handleKeyPress);
      
      // Custom setup button
      customSetupBtn.addEventListener('click', openCustomSetup);
      csClearBtn.addEventListener('click', clearCustomBoard);
      csRandomBtn.addEventListener('click', randomPairCustom);
      csBalanceBtn.addEventListener('click', balanceCustom);
      csStartBtn.addEventListener('click', applyCustomSetup);
      csCancelBtn.addEventListener('click', () => {
        closeCustomSetup();
        startOverlay.classList.add('active');
      });
      
      // ESC to close custom setup
      document.addEventListener('keydown', e => {
        if (e.key === 'Escape' && customSetupOverlay.classList.contains('active')) {
          closeCustomSetup();
          startOverlay.classList.add('active');
        }
      });
    }
    
    function handleKeyPress(e) {
      if (startOverlay.classList.contains('active') || 
          gameOverOverlay.classList.contains('active') || 
          winOverlay.classList.contains('active') ||
          customSetupOverlay.classList.contains('active')) {
        return;
      }
      
      switch(e.key) {
        case 'ArrowUp':
          e.preventDefault();
          move('up');
          break;
        case 'ArrowDown':
          e.preventDefault();
          move('down');
          break;
        case 'ArrowLeft':
          e.preventDefault();
          move('left');
          break;
        case 'ArrowRight':
          e.preventDefault();
          move('right');
          break;
      }
    }
    
    function startGame() {
      hideOverlays();
      initBoard();
      addRandomTile();
      addRandomTile();
      score = 0;
      moves = 0;
      hasWon = false;
      suppressWinUntilNew2048 = false;
      milestoneTiles.clear();
      highestTile = Math.max(...board.flat());
      renderBoard();
      updateStats();
      saveStateForUndo();
    }
    
    function restartGame() {
      startGame();
    }
    
    function continueGame() {
      hideOverlays();
    }
    
    function hideOverlays() {
      startOverlay.classList.remove('active');
      gameOverOverlay.classList.remove('active');
      winOverlay.classList.remove('active');
      customSetupOverlay.classList.remove('active');
    }
    
    function addRandomTile() {
      const emptyCells = [];
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (board[r][c] === 0) {
            emptyCells.push({r, c});
          }
        }
      }
      
      if (emptyCells.length > 0) {
        const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
        board[randomCell.r][randomCell.c] = Math.random() < 0.9 ? 2 : 4;
      }
    }
    
    function renderBoard() {
      gameBoard.innerHTML = '';
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const tile = document.createElement('div');
          tile.className = 'tile';
          const value = board[r][c];
          if (value > 0) {
            tile.textContent = value;
            tile.setAttribute('data-value', value);
          }
          gameBoard.appendChild(tile);
        }
      }
    }
    
    function updateStats() {
      scoreEl.textContent = score;
      movesEl.textContent = moves;
      highestTileEl.textContent = highestTile;
      
      const best = localStorage.getItem('best2048Score') || 0;
      bestEl.textContent = best;
    }
    
    function loadBestScore() {
      const best = localStorage.getItem('best2048Score') || 0;
      bestEl.textContent = best;
    }
    
    function saveStateForUndo() {
      // Placeholder for undo functionality
    }
    
    function move(direction) {
      const prevBoard = board.map(row => row.slice());
      let moved = false;
      let newMergedScore = 0;
      let new2048Created = false;
      
      if (direction === 'left') {
        for (let r = 0; r < SIZE; r++) {
          const result = slideRow(board[r]);
          board[r] = result.row;
          newMergedScore += result.mergedScore;
          if (result.new2048Created) new2048Created = true;
        }
      } else if (direction === 'right') {
        for (let r = 0; r < SIZE; r++) {
          const reversed = board[r].slice().reverse();
          const result = slideRow(reversed);
          board[r] = result.row.reverse();
          newMergedScore += result.mergedScore;
          if (result.new2048Created) new2048Created = true;
        }
      } else if (direction === 'up') {
        for (let c = 0; c < SIZE; c++) {
          const column = [];
          for (let r = 0; r < SIZE; r++) {
            column.push(board[r][c]);
          }
          const result = slideRow(column);
          for (let r = 0; r < SIZE; r++) {
            board[r][c] = result.row[r];
          }
          newMergedScore += result.mergedScore;
          if (result.new2048Created) new2048Created = true;
        }
      } else if (direction === 'down') {
        for (let c = 0; c < SIZE; c++) {
          const column = [];
          for (let r = 0; r < SIZE; r++) {
            column.push(board[r][c]);
          }
          const reversed = column.reverse();
          const result = slideRow(reversed);
          const finalColumn = result.row.reverse();
          for (let r = 0; r < SIZE; r++) {
            board[r][c] = finalColumn[r];
          }
          newMergedScore += result.mergedScore;
          if (result.new2048Created) new2048Created = true;
        }
      }
      
      // Check if board changed
      for (let r = 0; r < SIZE && !moved; r++) {
        for (let c = 0; c < SIZE && !moved; c++) {
          if (board[r][c] !== prevBoard[r][c]) {
            moved = true;
          }
        }
      }
      
      if (moved) {
        score += newMergedScore;
        moves++;
        highestTile = Math.max(highestTile, ...board.flat());
        addRandomTile();
        renderBoard();
        updateStats();
        saveStateForUndo();
        
        // Check win condition
        if (new2048Created) {
          suppressWinUntilNew2048 = false;
          checkWin();
        } else if (highestTile >= 2048 && !hasWon) {
          suppressWinUntilNew2048 = true;
        }
        
        // Save best score
        const currentBest = localStorage.getItem('best2048Score') || 0;
        if (score > currentBest) {
          localStorage.setItem('best2048Score', score);
        }
        
        // Check game over
        if (isGameOver()) {
          setTimeout(() => {
            document.getElementById('finalScore').textContent = score;
            gameOverOverlay.classList.add('active');
            speakStatus('Game over');
          }, 300);
        }
      }
    }
    
    function slideRow(row) {
      let arr = row.filter(v => v);
      let mergedScore = 0;
      let new2048Created = false;
      
      for (let i = 0; i < arr.length - 1; i++) {
        if (arr[i] === arr[i + 1]) {
          arr[i] *= 2;
          mergedScore += arr[i];
          if (arr[i] === 2048 && !hasWon) {
            new2048Created = true;
          }
          arr[i + 1] = 0;
          highestTile = Math.max(highestTile, arr[i]);
        }
      }
      
      arr = arr.filter(v => v);
      while (arr.length < SIZE) {
        arr.push(0);
      }
      
      return {row: arr, mergedScore, new2048Created};
    }
    
    function checkWin() {
      if (suppressWinUntilNew2048) return;
      if (highestTile >= 2048 && !hasWon) {
        hasWon = true;
        winOverlay.classList.add('active');
        speakStatus('You reached 2048!');
      }
    }
    
    function isGameOver() {
      // Check for empty cells
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (board[r][c] === 0) return false;
        }
      }
      
      // Check for possible merges
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const current = board[r][c];
          if ((r < SIZE - 1 && board[r + 1][c] === current) ||
              (c < SIZE - 1 && board[r][c + 1] === current)) {
            return false;
          }
        }
      }
      
      return true;
    }
    
    function speakStatus(message) {
      // Accessibility feature
      console.log(message);
    }
    
    // Custom Setup Functions
    function openCustomSetup() {
      hideOverlays();
      customSetupOverlay.classList.add('active');
      initCustomSetupGrid();
      setTimeout(() => {
        const first = customSetupGridEl.querySelector('.custom-cell');
        if (first) first.focus();
      }, 50);
    }
    
    function closeCustomSetup() {
      customSetupOverlay.classList.remove('active');
    }
    
    function initCustomSetupGrid() {
      customSetupGridEl.innerHTML = '';
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const cell = document.createElement('div');
          cell.className = 'custom-cell empty';
          cell.tabIndex = 0;
          cell.dataset.r = r;
          cell.dataset.c = c;
          updateCustomCellVisual(cell);
          
          cell.addEventListener('click', e => {
            cycleCellValue(r, c, e.shiftKey ? -1 : 1);
            updateCustomCellVisual(cell);
          });
          
          cell.addEventListener('keydown', e => {
            if (e.key === ' ' || e.key === 'Enter') {
              e.preventDefault();
              cycleCellValue(r, c, e.shiftKey ? -1 : 1);
              updateCustomCellVisual(cell);
            }
          });
          
          customSetupGridEl.appendChild(cell);
        }
      }
    }
    
    const cycleValues = [0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
    
    function cycleCellValue(r, c, dir = 1) {
      const cur = customBoardData[r][c];
      let idx = cycleValues.indexOf(cur);
      idx = (idx + dir + cycleValues.length) % cycleValues.length;
      customBoardData[r][c] = cycleValues[idx];
    }
    
    function updateCustomCellVisual(cell) {
      const r = +cell.dataset.r;
      const c = +cell.dataset.c;
      const val = customBoardData[r][c];
      cell.textContent = val ? val : '+';
      cell.classList.toggle('empty', !val);
      cell.setAttribute('aria-label', `Cell ${r + 1},${c + 1} value ${val || 'empty'}`);
      
      // Apply tile styling
      if (val > 0) {
        cell.setAttribute('data-value', val);
        cell.style.background = getComputedStyle(document.documentElement).getPropertyValue(`--tile-${val}`) || 
                               getComputedStyle(document.querySelector(`[data-value="${val}"]`))?.backgroundColor || 
                               '#eee4da';
      } else {
        cell.removeAttribute('data-value');
        cell.style.background = 'var(--tile-empty)';
      }
    }
    
    function clearCustomBoard() {
      customBoardData.forEach(row => row.fill(0));
      initCustomSetupGrid();
    }
    
    function randomPairCustom() {
      clearCustomBoard();
      let placed = 0;
      while (placed < 2) {
        const r = Math.floor(Math.random() * SIZE);
        const c = Math.floor(Math.random() * SIZE);
        if (!customBoardData[r][c]) {
          customBoardData[r][c] = Math.random() < 0.9 ? 2 : 4;
          placed++;
        }
      }
      initCustomSetupGrid();
    }
    
    function balanceCustom() {
      const count = customBoardData.flat().filter(v => v).length;
      if (count < 2) {
        for (let i = count; i < 2; i++) {
          const cell = randomEmptyCustom();
          if (cell) customBoardData[cell.r][cell.c] = 2;
        }
        initCustomSetupGrid();
      }
    }
    
    function randomEmptyCustom() {
      const arr = [];
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (!customBoardData[r][c]) arr.push({r, c});
        }
      }
      return arr.length ? arr[Math.floor(Math.random() * arr.length)] : null;
    }
    
    function validateCustomBoard(bd) {
      const nonEmpty = bd.flat().filter(v => v > 0);
      if (nonEmpty.length < 2) return {ok: false, reason: 'Need at least two tiles'};
      if (isBoardStuck(bd)) return {ok: false, reason: 'No possible moves — adjust tiles'};
      return {ok: true};
    }
    
    function isBoardStuck(bd) {
      const empties = bd.some(row => row.includes(0));
      if (empties) return false;
      
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (r + 1 < SIZE && bd[r][c] === bd[r + 1][c]) return false;
          if (c + 1 < SIZE && bd[r][c] === bd[r][c + 1]) return false;
        }
      }
      return true;
    }
    
    function applyCustomSetup() {
      const val = validateCustomBoard(customBoardData);
      if (!val.ok) {
        alert(val.reason);
        return;
      }
      
      board = customBoardData.map(r => r.slice());
      score = 0;
      moves = 0;
      highestTile = Math.max(...board.flat());
      hasWon = false;
      suppressWinUntilNew2048 = highestTile >= 2048;
      milestoneTiles = new Set();
      [128, 256, 512, 1024, 2048, 4096].forEach(m => {
        if (board.flat().includes(m)) milestoneTiles.add(m);
      });
      
      hideOverlays();
      customSetupOverlay.classList.remove('active');
      renderBoard();
      updateStats();
      saveStateForUndo();
      speakStatus('Custom game started');
    }
    
    // Initialize the game when page loads
    window.addEventListener('load', init);
  </script>
</body>
</html>

